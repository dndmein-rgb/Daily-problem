/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—“ï¸ Daily Question: December 27, 2025
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ Problem: 2402. Meeting Rooms III
ğŸ“Œ Link: https://leetcode.com/problems/meeting-rooms-iii/
ğŸ·ï¸ Difficulty: Hard
ğŸ† Topics: Array, Sorting, Heap (Priority Queue), Simulation, Greedy

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

You are given:
- n meeting rooms (numbered 0 to n-1)
- meetings[i] = [start_i, end_i] (meeting start and end times)

Rules:
1. Process meetings in order of their start times
2. If multiple rooms are free, assign the lowest numbered room
3. If no room is available, wait for the earliest available room and start then
4. A delayed meeting keeps its original duration

Return: The room number that held the most meetings (if tie, return smallest room)

Constraints:
- 1 â‰¤ n â‰¤ 100
- 1 â‰¤ meetings.length â‰¤ 10^5
- meetings[i].length == 2
- 0 â‰¤ start_i < end_i â‰¤ 5 * 10^5
- All start times are unique

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Approach 1: Simulation with Arrays (Brute Force)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Strategy: Track each room's availability time and simulate meeting assignments

Algorithm:
1ï¸âƒ£ Sort meetings by start time
2ï¸âƒ£ Maintain two arrays:
   â€¢ lastAvailableAt[i]: when room i will be free
   â€¢ roomsUsedCount[i]: how many meetings held in room i
3ï¸âƒ£ For each meeting:
   â€¢ Try to find first available room (room â‰¤ start time)
   â€¢ If found, assign it and update availability
   â€¢ If not found, find room that empties earliest
   â€¢ Delay meeting and extend room's availability
4ï¸âƒ£ Return room with maximum usage count (lowest number if tie)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SOLUTION 1: ARRAY SIMULATION (Simpler but O(n*m))
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Solution_ArraySimulation {
public:
    int mostBooked(int n, vector<vector<int>>& meetings) {
        int m = meetings.size();
        
        // ğŸ“… Sort meetings by start time (required by problem)
        sort(begin(meetings), end(meetings)); 
        
        // ğŸ“Š Track room usage and availability
        vector<int> roomsUsedCount(n, 0);         // Count meetings per room
        vector<long long> lastAvailableAt(n, 0);  // When each room becomes free
        
        // ğŸ”„ Process each meeting in chronological order
        for(vector<int>& meet : meetings) {
            int start = meet[0];
            int end   = meet[1];
            bool found = false;
            
            long long earliestEndRoomTime = LLONG_MAX;  // Track earliest available room
            int earliestEndRoom = 0;
            
            // ğŸ” Try to find first available room
            for(int room = 0; room < n; room++) {
                // âœ… Room is available at meeting start time
                if(lastAvailableAt[room] <= start) {
                    found = true;
                    lastAvailableAt[room] = end;  // Book until meeting ends
                    roomsUsedCount[room]++;
                    break;  // Always pick lowest numbered available room
                }
                
                // ğŸ“ Track which room becomes available earliest
                if(lastAvailableAt[room] < earliestEndRoomTime) {
                    earliestEndRoom = room;
                    earliestEndRoomTime = lastAvailableAt[room];
                }
            }
            
            // â° No room available - delay meeting in earliest available room
            if(!found) {
                // Meeting starts when room becomes free
                // Duration stays same: (end - start)
                lastAvailableAt[earliestEndRoom] += (end - start);
                roomsUsedCount[earliestEndRoom]++;
            }
        }
        
        // ğŸ† Find room with most meetings (lowest number if tie)
        int resultRoom = -1;
        int maxUse = 0;
        for(int room = 0; room < n; room++) {
            if(roomsUsedCount[room] > maxUse) {
                maxUse = roomsUsedCount[room];
                resultRoom = room;
            }
        }
        
        return resultRoom;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Approach 2: Priority Queue (Optimal Solution â­)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Strategy: Use heaps to efficiently track room availability

Key Insight:
â€¢ Don't iterate through all rooms for each meeting
â€¢ Use min-heap to get lowest numbered available room in O(log n)
â€¢ Use min-heap to track when rooms become free

Data Structures:
â€¢ unusedRooms: min-heap of available room numbers
â€¢ usedRooms: min-heap of {end_time, room_number} pairs

Algorithm:
1ï¸âƒ£ Sort meetings by start time
2ï¸âƒ£ Initially, all rooms are unused (in min-heap)
3ï¸âƒ£ For each meeting:
   a. Move rooms that are free by meeting start to unusedRooms
   b. If unused rooms exist:
      â€¢ Pop lowest numbered room
      â€¢ Schedule meeting, push to usedRooms
   c. Else (all rooms busy):
      â€¢ Get room that frees earliest from usedRooms
      â€¢ Delay meeting to start when room is free
      â€¢ Push back to usedRooms with new end time
4ï¸âƒ£ Return room with maximum usage

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SOLUTION 2: PRIORITY QUEUE APPROACH (Optimal â­)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Solution {
public:
    typedef pair<long long, int> P;  // {end_time, room_number}
    
    int mostBooked(int n, vector<vector<int>>& meetings) {
        int m = meetings.size();
        
        // ğŸ“… Sort meetings by start time
        sort(begin(meetings), end(meetings));
        
        // ğŸ“Š Track meeting count per room
        vector<int> roomsUsedCount(n, 0);
        
        // ğŸ”´ Min-heap: {end_time, room_number} - rooms currently in use
        priority_queue<P, vector<P>, greater<P>> usedRooms;
        
        // ğŸŸ¢ Min-heap: room_number - available rooms (lowest first)
        priority_queue<int, vector<int>, greater<int>> unusedRooms;
        
        // Initially all rooms are unused
        for(int room = 0; room < n; room++) {
            unusedRooms.push(room);
        }
        
        // ğŸ”„ Process each meeting
        for(vector<int>& meet : meetings) {
            int start = meet[0];
            int end   = meet[1];
            
            // â™»ï¸ Free up rooms that are available by meeting start time
            while(!usedRooms.empty() && usedRooms.top().first <= start) {
                int room = usedRooms.top().second;
                usedRooms.pop();
                unusedRooms.push(room);  // Room becomes available
            }
            
            // ğŸŸ¢ Case 1: We have available rooms
            if(!unusedRooms.empty()) {
                int room = unusedRooms.top();  // Get lowest numbered room
                unusedRooms.pop();
                usedRooms.push({end, room});   // Book room until meeting ends
                roomsUsedCount[room]++;
            }
            // ğŸ”´ Case 2: All rooms busy - delay meeting
            else {
                // Get room that becomes available earliest
                int room = usedRooms.top().second;
                long long endTime = usedRooms.top().first;
                usedRooms.pop();
                
                // Meeting starts when room is free
                // New end time = room_free_time + meeting_duration
                usedRooms.push({endTime + (end - start), room});
                roomsUsedCount[room]++;
            }
        }
        
        // ğŸ† Find room with most meetings (lowest number if tie)
        int resultRoom = -1;
        int maxUse = 0;
        for(int room = 0; room < n; room++) {
            if(roomsUsedCount[room] > maxUse) {
                maxUse = roomsUsedCount[room];
                resultRoom = room;
            }
        }
        
        return resultRoom;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” Example Walkthrough
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Example 1: n = 2, meetings = [[0,10],[1,5],[2,7],[3,4]]

Initial State:
    Rooms: 0, 1 (both available)
    Room usage: [0, 0]

Step 1: Meeting [0, 10]
    Start: 0, End: 10
    Available: Room 0, Room 1
    âœ… Assign Room 0 (lowest available)
    Room 0 busy until time 10
    Usage: [1, 0]

Step 2: Meeting [1, 5]
    Start: 1, End: 5
    Available: Room 1 (Room 0 busy until 10)
    âœ… Assign Room 1
    Room 1 busy until time 5
    Usage: [1, 1]

Step 3: Meeting [2, 7]
    Start: 2, End: 7
    Available: None (Room 0â†’10, Room 1â†’5)
    Room 1 frees first (at time 5)
    â° Delay meeting to time 5
    Duration: 7-2 = 5, so ends at 5+5 = 10
    âœ… Assign Room 1 (5â†’10)
    Usage: [1, 2]

Step 4: Meeting [3, 4]
    Start: 3, End: 4
    Available: None (Room 0â†’10, Room 1â†’10)
    Both free at same time (10), pick Room 0 (lower)
    â° Delay meeting to time 10
    Duration: 4-3 = 1, so ends at 10+1 = 11
    âœ… Assign Room 0 (10â†’11)
    Usage: [2, 2]

Final Usage: [2, 2] â†’ Tie! Return Room 0 (lower number)

Output: 0

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Example 2: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]

Initial: Rooms 0,1,2 available

[1,20]  â†’ Room 0 (1â†’20)    Usage: [1,0,0]
[2,10]  â†’ Room 1 (2â†’10)    Usage: [1,1,0]
[3,5]   â†’ Room 2 (3â†’5)     Usage: [1,1,1]
[4,9]   â†’ Room 2 free at 5 (4â†’9 delayed to 5â†’10)  Usage: [1,1,2]
[6,8]   â†’ Room 1 free at 10 (6â†’8 delayed to 10â†’12) Usage: [1,2,2]

Final: [1,2,2] â†’ Room 1 has most (tie with 2, return lower)

Output: 1

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

SOLUTION 1 (Array Simulation):
â° Time Complexity:  O(m log m + m*n)
   â””â”€ O(m log m): Sort meetings
   â””â”€ O(m*n): For each meeting, iterate through n rooms
   â””â”€ O(n): Find result room
   
ğŸ’¾ Space Complexity: O(n)
   â””â”€ Two arrays of size n
   â””â”€ Sorting space: O(log m)

SOLUTION 2 (Priority Queue):
â° Time Complexity:  O(m log m + m log n)
   â””â”€ O(m log m): Sort meetings
   â””â”€ O(m log n): Each meeting does heap operations (push/pop)
   â””â”€ O(n): Find result room
   
ğŸ’¾ Space Complexity: O(n)
   â””â”€ Two heaps combined store at most n rooms
   â””â”€ Usage count array: O(n)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Key Insights
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ Core Idea: Greedy room assignment
   â€¢ Always prefer available rooms over delaying
   â€¢ Always choose lowest numbered room when multiple available
   â€¢ Delayed meetings keep original duration

ğŸ”‘ Critical Observations:
   â€¢ Sorting meetings by start time is essential
   â€¢ Need to track when each room becomes free
   â€¢ Use long long for times (meetings can stack up)
   â€¢ Ties resolved by room number, not usage count order

âš ï¸ Edge Cases Handled:
   â€¢ All meetings fit without delay
   â€¢ All meetings must be delayed
   â€¢ Multiple rooms free at same time
   â€¢ Tie in usage count between rooms

ğŸ¯ Why Priority Queue is Better:
   â€¢ Avoid O(n) scan for each meeting
   â€¢ Automatically maintains lowest room number
   â€¢ Efficiently tracks earliest available room
   â€¢ Scales better with large n

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š State Transitions (Solution 2)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

For Each Meeting:

1. Check usedRooms heap:
   â””â”€ Free rooms that end â‰¤ meeting start
   â””â”€ Move them to unusedRooms heap

2. Assign Meeting:
   â”œâ”€ If unusedRooms NOT empty:
   â”‚  â””â”€ Pop lowest numbered room
   â”‚  â””â”€ Push {meeting_end, room} to usedRooms
   â”‚
   â””â”€ Else (all busy):
      â””â”€ Pop earliest ending room from usedRooms
      â””â”€ Calculate delayed end: room_end + duration
      â””â”€ Push back to usedRooms

3. Update room usage count

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸš€ Visual Example Trace (Solution 2)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

n = 2, meetings = [[0,10],[1,5],[2,7],[3,4]]

Time    Meeting   unusedRooms   usedRooms          Action           Usage
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Start     -       [0,1]         []                 Init             [0,0]
  0     [0,10]    [1]           [(10,0)]          Assign R0         [1,0]
  1     [1,5]     []            [(5,1),(10,0)]    Assign R1         [1,1]
  2     [2,7]     []            [(5,1),(10,0)]    Delayâ†’R1(5â†’10)    [1,2]
  3     [3,4]     []            [(10,0),(10,1)]   Delayâ†’R0(10â†’11)   [2,2]

Result: Room 0 (tie, return lowest)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ”„ Comparison: Solution 1 vs Solution 2
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Aspect              Solution 1              Solution 2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Time Complexity     O(m*n)                  O(m log n) â­
Space Complexity    O(n)                    O(n)
Implementation      Simpler                 More complex
Room Search         Linear scan             Heap pop
Best For            Small n                 Large n or m
Optimization        None                    Heap-based â­

Recommendation: Use Solution 2 for optimal performance, especially with
                large inputs. Solution 1 is good for understanding logic.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… Common Pitfalls to Avoid
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âŒ Forgetting to sort meetings by start time
âŒ Using int instead of long long for times (overflow!)
âŒ Not preserving meeting duration when delaying
âŒ Checking availability wrong (should be â‰¤ not <)
âŒ Returning highest usage room instead of checking ties properly
âŒ Not initializing all rooms as unused in heap solution

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
