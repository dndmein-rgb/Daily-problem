/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—“ï¸ Daily Question: December 22, 2025
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ Problem: 960. Delete Columns to Make Sorted III
ğŸ“Œ Link: https://leetcode.com/problems/delete-columns-to-make-sorted-iii/
ğŸ·ï¸ Difficulty: Hard
ğŸ† Topics: Array, String, Dynamic Programming

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Given an array of strings (all same length):
- Delete minimum columns so that remaining columns make rows lexicographically sorted
- Unlike Problem II: Can delete ANY columns (not just checking left to right)

Goal: Find minimum deletions to make all remaining columns work together

Key Difference from Problem I & II:
- Problem I: Each column independent â†’ check if sorted
- Problem II: Process left to right â†’ skip already sorted pairs
- Problem III: Can choose ANY subset of columns â†’ find longest valid subsequence

Example:
  strs = ["babca", "bbazb", "cbccc"]
  
  Grid view:
    b a b c a  â† row 0
    b b a z b  â† row 1
    c b c c c  â† row 2
  
  Keep columns 0, 1, 3:
    b a c  â† sorted? "bac" âœ…
    b b z  â† sorted? "bbz" âœ…
    c b c  â† sorted? "cbc" âœ…
  
  All rows sorted! Delete 2 columns (2, 4)
  Answer: 2

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Approach
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Strategy: Longest Increasing Subsequence (LIS) on Columns

Key Insight:
- Instead of "which to delete", think "which to KEEP"
- We want to keep maximum columns such that rows remain sorted
- This is LIS problem where "increasing" = "valid column order"

Algorithm:
1ï¸âƒ£ Define "valid order" between columns:
   - Column j can come before column i if:
   - For ALL rows: strs[row][j] â‰¤ strs[row][i]

2ï¸âƒ£ Use DP to find longest chain of valid columns:
   - dp[i] = longest valid subsequence ending at column i
   - For each i, check all j < i
   - If column j can come before i â†’ dp[i] = max(dp[i], dp[j] + 1)

3ï¸âƒ£ Find maximum dp value (longest valid subsequence)

4ï¸âƒ£ Answer = total columns - longest subsequence

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” Example Walkthrough
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Input: strs = ["bab", "ddb", "cbd"]

Grid:
  Column:  0  1  2
          b  a  b  â† row 0
          d  d  b  â† row 1
          c  b  d  â† row 2

Step 1: Initialize DP
  dp = [1, 1, 1]  // Each column can form a subsequence of length 1

Step 2: Process each column

i = 0 (column 0: b, d, c):
  No previous columns
  dp[0] = 1

i = 1 (column 1: a, d, b):
  Check j = 0 (column 0: b, d, c):
    Row 0: 'b' â‰¤ 'a'? NO (b > a) âŒ
  Invalid, dp[1] = 1

i = 2 (column 2: b, b, d):
  Check j = 0 (column 0: b, d, c):
    Row 0: 'b' â‰¤ 'b'? YES âœ…
    Row 1: 'd' â‰¤ 'b'? NO (d > b) âŒ
  Invalid
  
  Check j = 1 (column 1: a, d, b):
    Row 0: 'a' â‰¤ 'b'? YES âœ…
    Row 1: 'd' â‰¤ 'b'? NO (d > b) âŒ
  Invalid
  
  dp[2] = 1

Step 3: Find LIS
  lis = max(1, 1, 1) = 1

Step 4: Calculate deletions
  Answer = 3 - 1 = 2

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â° Time Complexity:  O(colsÂ² Ã— rows)
   â””â”€ Outer loop: cols iterations
   â””â”€ Inner loop: up to cols iterations
   â””â”€ Validation: rows comparisons
   â””â”€ Total: O(colsÂ² Ã— rows)
   
ğŸ’¾ Space Complexity: O(cols)
   â””â”€ dp array of size cols

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

class Solution {
public:
    int minDeletionSize(vector<string>& strs) {
        int rows = strs.size();
        int cols = strs[0].size();
        
        // ğŸ“Š dp[i] = length of longest valid column subsequence ending at column i
        vector<int> dp(cols, 1);  // Each column alone is valid (length 1)
        int lis = 1;              // Track longest increasing subsequence
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Step 1: Build DP table using LIS approach
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        for (int i = 0; i < cols; i++) {
            
            // Check all previous columns
            for (int j = 0; j < i; j++) {
                
                // ğŸ” Validate: Can column j come before column i?
                // Check if for ALL rows: strs[row][j] â‰¤ strs[row][i]
                bool valid = true;
                for (int row = 0; row < rows; row++) {
                    if (strs[row][j] > strs[row][i]) {
                        valid = false;
                        break;  // Early exit on first violation
                    }
                }
                
                // âœ… If valid, extend subsequence from j
                if (valid) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            
            // Track maximum subsequence length
            lis = max(lis, dp[i]);
        }
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Step 2: Calculate minimum deletions
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Keep longest valid subsequence, delete rest
        return cols - lis;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Key Insights
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ Core Pattern: LIS (Longest Increasing Subsequence)
   - Classic LIS: find longest increasing sequence in array
   - Here: find longest valid column sequence
   - "Increasing" = column j can precede column i

ğŸ”‘ Why This Works:
   - We want to KEEP maximum columns
   - "Minimum deletions" = "Maximum kept" complement
   - Kept columns must form valid ordering
   - This is exactly LIS on columns!

âš ï¸ Validation Logic:
   Column j can precede column i if:
     âˆ€ rows: strs[row][j] â‰¤ strs[row][i]
   
   Must be true for ALL rows (not just one!)

ğŸ¯ DP Recurrence:
   dp[i] = max(dp[i], dp[j] + 1)  where column j can precede i
   
   Translation: "Best subsequence ending at i is either:
   - Just column i alone (dp[i] = 1)
   - Extend some previous valid subsequence"

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š Detailed Example with DP Table
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Input: ["cba", "daf", "ghi"]

Grid:
  Col:  0  1  2
        c  b  a  â† row 0
        d  a  f  â† row 1
        g  h  i  â† row 2

Process:

i=0 (c,d,g):
  dp[0] = 1

i=1 (b,a,h):
  Check j=0 (c,d,g):
    Row 0: c â‰¤ b? NO âŒ
  dp[1] = 1

i=2 (a,f,i):
  Check j=0 (c,d,g):
    Row 0: c â‰¤ a? NO âŒ
  
  Check j=1 (b,a,h):
    Row 0: b â‰¤ a? NO âŒ
  
  dp[2] = 1

Final: lis = max(1,1,1) = 1
Answer: 3 - 1 = 2

Meaning: Can only keep 1 column at most!

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ†š Comparison: Problem I vs II vs III
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Aspect   â”‚ Problem I       â”‚ Problem II      â”‚ Problem III     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Goal     â”‚ Each col sorted â”‚ Rows sorted     â”‚ Rows sorted     â”‚
â”‚ Approach â”‚ Check each col  â”‚ Greedy + state  â”‚ DP (LIS)        â”‚
â”‚ Deletion â”‚ Independent     â”‚ Sequential      â”‚ Optimal subset  â”‚
â”‚ Pattern  â”‚ Simple check    â”‚ State machine   â”‚ LIS variant     â”‚
â”‚ Time     â”‚ O(nÃ—m)          â”‚ O(nÃ—m)          â”‚ O(mÂ²Ã—n)         â”‚
â”‚ Diff     â”‚ Easy            â”‚ Medium          â”‚ Hard            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Problem III is hardest because:
- Must find OPTIMAL column subset
- Not just greedy left-to-right
- Requires DP optimization

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¯ Why LIS Pattern?
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Classic LIS:
  Array: [10, 9, 2, 5, 3, 7, 101, 18]
  LIS: [2, 3, 7, 18] (length 4)
  
  dp[i] = longest increasing subsequence ending at i

This Problem:
  Columns: [col0, col1, col2, ...]
  Valid sequence: columns that maintain row ordering
  
  dp[i] = longest valid column sequence ending at column i

Same pattern, different "increasing" definition!

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸš€ Optimization Ideas
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Current: O(colsÂ² Ã— rows)

Possible optimizations:
1. Early termination in validation loop
2. Memoize column comparisons (if rows large)
3. Use segment tree for range queries (advanced)

For most inputs, current solution is optimal!

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Related Problems
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Similar patterns:
- Longest Increasing Subsequence (LeetCode 300) - foundation
- Delete Columns to Make Sorted I & II
- Russian Doll Envelopes (2D LIS)
- Maximum Length of Pair Chain
- Number of Longest Increasing Subsequence

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Learning Points
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. âœ… Recognize LIS variants in different contexts
2. âœ… Transform "minimum deletion" to "maximum retention"
3. âœ… Custom ordering definitions (not just numeric comparison)
4. âœ… DP on subsequences
5. âœ… Column-wise thinking in grid problems

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
