/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—“ï¸ Daily Question: December 21, 2025
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ Problem: 955. Delete Columns to Make Sorted II
ğŸ“Œ Link: https://leetcode.com/problems/delete-columns-to-make-sorted-ii/
ğŸ·ï¸ Difficulty: Medium
ğŸ† Topics: Array, String, Greedy

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Given an array of strings (all same length):
- Delete minimum columns so that remaining columns make rows lexicographically sorted
- Unlike Problem I: We care about FULL STRING comparison after deletion
- Once two adjacent rows are already sorted (row[i] < row[i+1]), we can ignore
  future violations between them

Key Difference from Problem I:
- Problem I: Each column independent
- Problem II: Columns work together to ensure row ordering

Example:
  strs = ["ca", "bb", "ac"]
  
  Initially:
    ca  â† row 0
    bb  â† row 1
    ac  â† row 2
  
  Check Column 0 (c, b, a):
    row[0] vs row[1]: 'c' > 'b' âŒ Delete column 0!
  
  After deleting column 0:
    a  â† row 0
    b  â† row 1
    c  â† row 2
  
  Sorted! âœ… Answer: 1

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Approach
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Strategy: Greedy with "Already Sorted" Tracking

Key Insight:
Once we determine that row[i] < row[i+1] based on seen columns, we mark this
pair as "already sorted". Future violations between this pair can be ignored!

Algorithm:
1ï¸âƒ£ Maintain alreadySorted[] array for adjacent row pairs
2ï¸âƒ£ For each column:
   a. Check if it violates any pair that's NOT already sorted
   b. If violation found â†’ delete this column
   c. If no violation â†’ mark pairs as sorted where strs[i][col] < strs[i+1][col]
3ï¸âƒ£ Return count of deleted columns

State Machine:
  For each pair (row[i], row[i+1]):
    NOT sorted â†’ Check column â†’ Violation? Delete : Mark sorted
    Already sorted â†’ Skip checking (already determined to be sorted)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” Example Walkthrough
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Input: strs = ["xc", "yb", "za"]

Initial State:
  alreadySorted = [false, false]  // pairs: (0,1) and (1,2)

Column 0: x, y, z
  Check pair (0,1): 'x' vs 'y'
    'x' < 'y' âœ… No violation
  Check pair (1,2): 'y' vs 'z'
    'y' < 'z' âœ… No violation
  
  No deletions! Update alreadySorted:
    pair (0,1): 'x' < 'y' â†’ alreadySorted[0] = true
    pair (1,2): 'y' < 'z' â†’ alreadySorted[1] = true
  
  alreadySorted = [true, true]

Column 1: c, b, a
  Check pair (0,1): alreadySorted[0] = true â†’ SKIP!
  Check pair (1,2): alreadySorted[1] = true â†’ SKIP!
  
  All pairs already sorted, no need to check!

Result: 0 deletions

After keeping both columns:
  Rows: "xc", "yb", "za"
  "xc" < "yb" < "za" âœ… Lexicographically sorted!

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â° Time Complexity:  O(n Ã— m)
   â””â”€ n = number of strings (rows)
   â””â”€ m = length of each string (columns)
   â””â”€ Each cell visited at most once
   â””â”€ Early termination when all pairs are sorted
   
ğŸ’¾ Space Complexity: O(n)
   â””â”€ alreadySorted array of size (n-1)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

class Solution {
public:
    int minDeletionSize(vector<string>& strs) {
        int rows = strs.size();
        int cols = strs[0].size();
        
        int deletion = 0;
        
        // ğŸ“Š Track which adjacent row pairs are already determined to be sorted
        // alreadySorted[i] = true means strs[i] < strs[i+1] is confirmed
        vector<bool> alreadySorted(rows - 1, false);
        
        // ğŸ”„ Process each column left to right
        for (int col = 0; col < cols; col++) {
            bool deleted = false;
            
            // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
            // Step 1: Check if this column causes violations
            // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
            for (int row = 0; row < rows - 1; row++) {
                // ğŸ”‘ KEY: Only check pairs that aren't already sorted!
                // If alreadySorted[row] = true, we already know strs[row] < strs[row+1]
                // So any violation here doesn't matter
                if (!alreadySorted[row] && strs[row][col] > strs[row + 1][col]) {
                    // âŒ Violation found! Must delete this column
                    deleted = true;
                    deletion++;
                    break;  // No need to check further
                }
            }
            
            // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
            // Step 2: If column not deleted, update alreadySorted
            // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
            if (deleted) {
                continue;  // Skip updating if we deleted this column
            }
            
            // ğŸ¯ Mark pairs as sorted when we find strict inequality
            for (int row = 0; row < rows - 1; row++) {
                // If this pair shows strs[row] < strs[row+1], they're sorted!
                // Once sorted, they stay sorted (can't un-sort)
                // Use bitwise OR to preserve existing true values
                alreadySorted[row] = alreadySorted[row] || (strs[row][col] < strs[row + 1][col]);
            }
        }
        
        return deletion;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Key Insights
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ Core Concept: Lexicographic Ordering with Early Determination
   - Once we know strs[i] < strs[i+1] from earlier columns,
     later columns don't matter for this comparison
   
ğŸ”‘ Why alreadySorted Works:
   - Lexicographic comparison stops at first difference
   - If "abc" < "abd", we know it from position 2 ('c' < 'd')
   - Position 3+ don't matter for this comparison
   
âš ï¸ Common Pitfalls:
   - Forgetting to check !alreadySorted[row] before violation check
   - Using '=' instead of '|' when updating alreadySorted
   - Continuing to check all rows even after finding violation

ğŸ¯ Greedy Choice:
   - We process columns left to right (greedy order)
   - Each column is either kept or deleted
   - No backtracking needed

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š Detailed Example with State Tracking
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Input: ["ca", "bb", "ac"]

Initial:
  ca  â† row 0
  bb  â† row 1
  ac  â† row 2
  
  alreadySorted = [false, false]
  deletions = 0

Column 0: [c, b, a]
  Check row 0: alreadySorted[0]=false
    'c' > 'b' âŒ VIOLATION!
    Delete column 0
    deletions = 1
  Continue to next column (don't update alreadySorted)

Column 1: [a, b, c]
  Check row 0: alreadySorted[0]=false
    'a' < 'b' âœ… No violation
  Check row 1: alreadySorted[1]=false
    'b' < 'c' âœ… No violation
  
  No deletions! Update alreadySorted:
    'a' < 'b' â†’ alreadySorted[0] = true
    'b' < 'c' â†’ alreadySorted[1] = true

Final:
  Remaining columns: [column 1]
  Rows become: "a", "b", "c"
  "a" < "b" < "c" âœ… Sorted!
  Answer: 1

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¯ Why Bitwise OR (|) for alreadySorted Update?
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

alreadySorted[i] = alreadySorted[i] | (strs[i][col] < strs[i+1][col]);

Truth table:
  Old Value | New Check | Result | Meaning
  ----------|-----------|--------|------------------
  false     | false     | false  | Still not sorted
  false     | true      | true   | Just became sorted!
  true      | false     | true   | Already sorted (stays sorted)
  true      | true      | true   | Already sorted (stays sorted)

Key: Once true, always true! Can't "un-sort" a pair.

Alternative (equivalent):
  if (strs[i][col] < strs[i+1][col]) {
      alreadySorted[i] = true;
  }

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸš€ Optimization: Early Termination
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

We can stop early if all pairs are already sorted:

for (int col = 0; col < cols; col++) {
    // ğŸ¯ Early termination check
    bool allSorted = true;
    for (int row = 0; row < rows - 1; row++) {
        if (!alreadySorted[row]) {
            allSorted = false;
            break;
        }
    }
    if (allSorted) {
        break;  // All pairs determined, remaining columns don't matter!
    }
    
    // ... rest of column processing
}

This optimization can save significant time when rows become sorted early!

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š Comparison: Problem I vs Problem II
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Aspect           â”‚ Problem I           â”‚ Problem II          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Goal             â”‚ Each column sorted  â”‚ Rows sorted (lex)   â”‚
â”‚ Columns          â”‚ Independent         â”‚ Work together       â”‚
â”‚ State tracking   â”‚ None needed         â”‚ alreadySorted array â”‚
â”‚ Complexity       â”‚ O(n Ã— m)            â”‚ O(n Ã— m)            â”‚
â”‚ Early exit       â”‚ Per column          â”‚ Per column + global â”‚
â”‚ Difficulty       â”‚ Easy                â”‚ Medium              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Related Problems
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Similar patterns:
- Delete Columns to Make Sorted I (easier)
- Delete Columns to Make Sorted III (harder, DP)
- Minimum Number of Removals to Make Array Sorted
- Is Subsequence
- Longest Increasing Subsequence

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
