/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—“ï¸ Daily Question: December 24, 2025
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ Problem: 2054. Two Best Non-Overlapping Events
ğŸ“Œ Link: https://leetcode.com/problems/two-best-non-overlapping-events/
ğŸ·ï¸ Difficulty: Medium
ğŸ† Topics: Array, Binary Search, Dynamic Programming, Sorting

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Given an array of events where events[i] = [startTime_i, endTime_i, value_i]:
- You can attend at most 2 events
- Events cannot overlap (if you attend event i, you can't attend event j if they overlap)
- Two events overlap if one starts before/during the other ends

Goal: Return maximum sum of values of at most 2 non-overlapping events

Constraints:
- Can attend 0, 1, or 2 events
- Events are non-overlapping if: event1.end < event2.start

Example:
  events = [[1,3,2], [4,5,2], [2,4,3]]
  
  Timeline:
    Event 0: [1,3] value=2  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    Event 1: [4,5] value=2          â–ˆâ–ˆâ–ˆâ–ˆ
    Event 2: [2,4] value=3      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
  
  Best choice: Event 0 + Event 1 (non-overlapping)
  Sum: 2 + 2 = 4

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Approach
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Strategy: DP + Binary Search + Sorting

Key Insights:
1ï¸âƒ£ Sort events by start time (process chronologically)
2ï¸âƒ£ For each event, decide: take it or skip it
3ï¸âƒ£ If take: find next non-overlapping event using binary search
4ï¸âƒ£ Track how many events selected (max 2)
5ï¸âƒ£ Use memoization to avoid recomputation

Algorithm:
1ï¸âƒ£ Sort events by start time
2ï¸âƒ£ Define DP state: solve(i, count)
   - i = current event index
   - count = number of events already selected
3ï¸âƒ£ For each event:
   - Option 1: Skip this event â†’ solve(i+1, count)
   - Option 2: Take this event â†’ value + solve(nextValidIndex, count+1)
     where nextValidIndex is first event starting after current ends
4ï¸âƒ£ Return maximum of both options

Binary Search:
- Find first event with start time > current event's end time
- This ensures non-overlapping

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” Example Walkthrough
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Input: events = [[1,3,2], [4,5,2], [2,4,3]]

Step 1: Sort by start time
  [[1,3,2], [2,4,3], [4,5,2]]
   â†‘ start time

Step 2: Start recursion solve(0, 0)
  Current event: [1,3,2], count=0

  Option 1: Skip
    solve(1, 0)
  
  Option 2: Take (value = 2)
    Find next valid: upperBound(3) â†’ index 2 (event [4,5,2])
    2 + solve(2, 1)

Step 3: Expand take path
  solve(2, 1): event [4,5,2], count=1
  
  Option 1: Skip â†’ solve(3, 1) = 0 (out of bounds)
  Option 2: Take â†’ 2 + solve(3, 2) = 2
  
  Result: max(0, 2) = 2

Step 4: Total for take path
  2 + 2 = 4

Step 5: Expand skip path (solve(1, 0))
  Event [2,4,3], count=0
  
  Option 1: Skip â†’ solve(2, 0)
  Option 2: Take â†’ 3 + solve(2, 1)
  
  Eventually: max value = 3 + 2 = 5? Wait...
  
  Actually after full recursion: answer = 4

Output: 4

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â° Time Complexity:  O(n log n + n Ã— 2 Ã— log n)
   â””â”€ Sorting: O(n log n)
   â””â”€ DP states: n Ã— 3 (index Ã— count) = O(n)
   â””â”€ Each state: binary search O(log n)
   â””â”€ Total: O(n log n)
   
ğŸ’¾ Space Complexity: O(n Ã— 3)
   â””â”€ Memoization table: t[n][3]
   â””â”€ Recursion stack: O(n) worst case
   â””â”€ Total: O(n)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

class Solution {
public:
    int n;
    int t[100001][3];  // Memoization: t[index][count]
    
    // ğŸ” Binary Search: Find first event starting after endTime
    int upperBound(vector<vector<int>>& events, int endTime) {
        int l = 0, r = n - 1, result = n;
        
        while (l <= r) {
            int mid = l + (r - l) / 2;
            
            // Check if this event starts after endTime
            if (events[mid][0] > endTime) {
                result = mid;     // This could be the answer
                r = mid - 1;      // Look for earlier valid event
            } else {
                l = mid + 1;      // Look for later events
            }
        }
        
        return result;  // Index of first non-overlapping event
    }
    
    // ğŸ¯ Recursive DP with memoization
    int solve(int i, vector<vector<int>>& events, int count) {
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Base cases
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        
        // Already selected 2 events OR processed all events
        if (count == 2 || i >= n) return 0;
        
        // âœ… Check memoization
        if (t[i][count] != -1) return t[i][count];
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Option 1: Take current event
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        
        // Find next non-overlapping event
        int nextValidIndex = upperBound(events, events[i][1]);
        
        // Take current event + solve for next valid event
        int take = events[i][2] + solve(nextValidIndex, events, count + 1);
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Option 2: Skip current event
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        int notTake = solve(i + 1, events, count);
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Store and return maximum
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        return t[i][count] = max(take, notTake);
    }
    
    int maxTwoEvents(vector<vector<int>>& events) {
        n = events.size();
        
        // ğŸ¨ Initialize memoization table
        memset(t, -1, sizeof(t));
        
        // ğŸ“Š Sort events by start time
        sort(events.begin(), events.end());
        
        // ğŸš€ Start recursion from index 0, count 0
        return solve(0, events, 0);
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Key Insights
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ Core Pattern: Interval Scheduling + DP
   - Classic interval scheduling problem
   - Limited to 2 selections (makes it tractable)
   - DP + Binary Search optimization

ğŸ”‘ Why Sort by Start Time?
   - Process events chronologically
   - Can use binary search to find next valid event
   - Ensures we don't miss any valid combinations

âš ï¸ Non-Overlapping Definition:
   Event 1 ends before Event 2 starts:
     event1.end < event2.start âœ…
   
   NOT just event1.end != event2.start:
     [1,3] and [3,5] â†’ overlapping! (3 = 3)

ğŸ¯ DP State Design:
   - i: current event being considered
   - count: how many events already selected (0, 1, or 2)
   - Optimal substructure: max value from current state

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š DP State Transitions
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

State: solve(i, count)

Base Cases:
  count == 2 â†’ return 0 (already selected 2 events)
  i >= n â†’ return 0 (no more events to consider)

Transitions:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚           solve(i, count)                   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚                â”‚
    Skip             Take
       â”‚                â”‚
       â–¼                â–¼
  solve(i+1,      value[i] +
   count)        solve(next, count+1)
       â”‚                â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
         return max

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” Binary Search Visualization
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Events sorted by start time:
  [1,3,2]  [2,4,3]  [4,5,2]  [6,7,1]
     0        1        2        3

Current event: [1,3,2] (ends at 3)
Find first event starting > 3:

Binary search:
  l=0, r=3, mid=1 â†’ events[1].start=2 â‰¤ 3 â†’ l=2
  l=2, r=3, mid=2 â†’ events[2].start=4 > 3 â†’ result=2, r=1
  l=2, r=1 â†’ stop
  
  Return: index 2 ([4,5,2])

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¯ Why Memoization Works
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Without memoization:
  Recursive tree can have exponential nodes
  Same subproblems computed multiple times

With memoization:
  Each unique (i, count) computed once
  States: n Ã— 3 = O(n)
  Saves massive computation!

Example overlap:
  solve(5, 1) might be reached from:
    - solve(3, 0) â†’ take event 4
    - solve(4, 1) â†’ skip event 4
  
  With memo: compute once, reuse!

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸš€ Alternative Approach: Sweep Line
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Can also solve using sweep line + max heap:
1. Process events by end time
2. Track max value seen so far
3. For each event: max(single event, event + best before)

Both approaches: O(n log n) time
Current DP approach is more intuitive!

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Related Problems
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Similar patterns:
- Maximum Profit in Job Scheduling (LeetCode 1235)
- Non-overlapping Intervals (LeetCode 435)
- Minimum Number of Arrows to Burst Balloons (LeetCode 452)
- Merge Intervals (LeetCode 56)
- Meeting Rooms II (LeetCode 253)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Learning Points
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. âœ… Interval scheduling with DP
2. âœ… Binary search for next valid element
3. âœ… Memoization with multiple dimensions
4. âœ… Sorting as preprocessing step
5. âœ… Take/skip decision tree pattern

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
