/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—“ï¸ Daily Problem: LeetCode 2092
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ Problem: 2092. Find All People With Secret
ğŸ“Œ Platform: LeetCode
ğŸ·ï¸ Difficulty: Hard
ğŸ† Topics: Graph, Dijkstra, Priority Queue, Shortest Path

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Person 0 has a secret and shares it with `firstPerson` at $t=0$. Meetings 
between people occur at specific times. If a person attending a meeting knows 
the secret, the other person learns it instantaneously. We need to find all 
the people who know the secret after all meetings have concluded.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Approach (Dijkstra / Modified BFS)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Instead of using Union-Find to group meetings by time, we can model this as a 
**Shortest Path Problem** on a graph where "distance" is actually the 
**earliest time** a person learns the secret.

1.  **Graph Construction**: Represent the meetings as an adjacency list where 
    each entry stores the neighbor and the specific meeting time.
2.  **State Tracking**: Use an `earliestSecret` array to keep track of the 
    first possible moment each person is "infected" by the secret.
3.  **Dijkstra's Algorithm**: 
    * Use a Min-Priority Queue to always process the person who learned the 
      secret the earliest.
    * **Relaxation Condition**: A person $u$ can share the secret with $v$ if 
      the meeting time $T \ge$ the time $u$ learned the secret. If this 
      $T$ is earlier than the time $v$ currently knows, update $v$'s time 
      and push to the queue.



â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ§  Algorithm Walkthrough
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Example: `n=4`, `meetings=[[1,2,5], [2,3,5], [0,1,10]]`, `firstPerson=3`

1.  **Initialize**: `earliestSecret[0] = 0`, `earliestSecret[3] = 0`. Others = $\infty$.
2.  **Process Node 3 ($t=0$)**:
    * Meeting with 2 at $t=5$. Since $5 \ge 0$, Node 2 learns it at $t=5$.
3.  **Process Node 2 ($t=5$)**:
    * Meeting with 1 at $t=5$. Since $5 \ge 5$, Node 1 learns it at $t=5$.
4.  **Process Node 1 ($t=5$)**:
    * Meeting with 0 at $t=10$. Node 0 already knows it at $t=0$.
5.  **Result**: People with `earliestSecret < âˆ` are $\{0, 1, 2, 3\}$.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš™ï¸ Implementation
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

class Solution {
public:
    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {
        // Build the graph: node -> {neighbor, time}
        vector<vector<pair<int, int>>> adj(n);
        for (auto& m : meetings) {
            adj[m[0]].push_back({m[1], m[2]});
            adj[m[1]].push_back({m[0], m[2]});
        }

        // earliestSecret[i] = earliest time person i knows the secret
        vector<int> earliestSecret(n, INT_MAX);
        earliestSecret[0] = 0;
        earliestSecret[firstPerson] = 0;

        // Min-priority queue: {time_learned, person}
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, 0});
        pq.push({0, firstPerson});

        while (!pq.empty()) {
            auto [time_u, u] = pq.top();
            pq.pop();

            // Optimization: If we already found an earlier path, skip
            if (time_u > earliestSecret[u]) continue;

            for (auto& edge : adj[u]) {
                int v = edge.first;
                int meeting_time = edge.second;

                // Rule: You can only share the secret if the meeting happens 
                // at or after you learned it.
                if (meeting_time >= time_u && earliestSecret[v] > meeting_time) {
                    earliestSecret[v] = meeting_time;
                    pq.push({meeting_time, v});
                }
            }
        }

        vector<int> result;
        for (int i = 0; i < n; i++) {
            if (earliestSecret[i] != INT_MAX) {
                result.push_back(i);
            }
        }
        return result;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

* **Time Complexity**: $O(M \log M + N)$, where $M$ is the number of meetings. 
  Each meeting is pushed into the priority queue at most once per direction.
* **Space Complexity**: $O(N + M)$ for the adjacency list and the 
  `earliestSecret` tracking array.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Key Notes
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

* **Why Dijkstra?**: It naturally handles the "earliest possible" requirement 
  and manages the time constraints without needing complex grouping or resets.
* **Instantaneous Sharing**: Because we use a priority queue based on time, 
  we correctly handle chains of meetings occurring at the same timestamp.
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
