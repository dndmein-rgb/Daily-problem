/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—“ï¸ Daily Question: December 20, 2025
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ Problem: 944. Delete Columns to Make Sorted
ğŸ“Œ Link: https://leetcode.com/problems/delete-columns-to-make-sorted/
ğŸ·ï¸ Difficulty: Easy
ğŸ† Topics: Array, String

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Given an array of strings (all same length):
- Each string represents a row
- Characters in the same column position form a column

Goal: Find minimum number of columns that are NOT sorted in ascending order

A column is sorted if: strs[0][i] â‰¤ strs[1][i] â‰¤ strs[2][i] â‰¤ ...

Example:
  strs = ["cba", "daf", "ghi"]
  
  Visualize as grid:
    c b a  â† Row 0
    d a f  â† Row 1
    g h i  â† Row 2
    â†“ â†“ â†“
    Col0: c,d,g â†’ sorted âœ… (c < d < g)
    Col1: b,a,h â†’ NOT sorted âŒ (b > a)
    Col2: a,f,i â†’ sorted âœ… (a < f < i)
  
  Answer: 1 (delete column 1)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Approach
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Strategy: Column-by-Column Validation

Algorithm:
1ï¸âƒ£ Iterate through each column (0 to m-1)
2ï¸âƒ£ For each column, check if sorted:
   - Compare each character with the previous row's character
   - If any character is less than previous â†’ column is unsorted
3ï¸âƒ£ Count unsorted columns
4ï¸âƒ£ Return count

Visual Process:
  For each column i:
    Check: strs[0][i] â‰¤ strs[1][i] â‰¤ strs[2][i] â‰¤ ... â‰¤ strs[n-1][i]
    If any violation found â†’ count++

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” Example Walkthrough
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Input: strs = ["cba", "daf", "ghi"]

Step 1: Check Column 0 (index i=0)
  strs[0][0] = 'c'
  strs[1][0] = 'd'  â†’ 'd' >= 'c' âœ…
  strs[2][0] = 'g'  â†’ 'g' >= 'd' âœ…
  Result: Sorted! count = 0

Step 2: Check Column 1 (index i=1)
  strs[0][1] = 'b'
  strs[1][1] = 'a'  â†’ 'a' < 'b' âŒ VIOLATION!
  Result: Not sorted! count = 1, break

Step 3: Check Column 2 (index i=2)
  strs[0][2] = 'a'
  strs[1][2] = 'f'  â†’ 'f' >= 'a' âœ…
  strs[2][2] = 'i'  â†’ 'i' >= 'f' âœ…
  Result: Sorted! count = 1

Output: 1

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â° Time Complexity:  O(n Ã— m)
   â””â”€ n = number of strings (rows)
   â””â”€ m = length of each string (columns)
   â””â”€ We check each position once (with early break optimization)
   
ğŸ’¾ Space Complexity: O(1)
   â””â”€ Only using constant extra space (count variable)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

class Solution {
public:
    int minDeletionSize(vector<string>& strs) {
        int n = strs.size();      // Number of rows
        int m = strs[0].size();   // Number of columns (length of each string)
        int count = 0;            // Count of unsorted columns
        
        // ğŸ”„ Iterate through each column
        for (int i = 0; i < m; i++) {
            
            // ğŸ” Check if this column is sorted
            // Compare each row with the previous row
            for (int j = 1; j < n; j++) {
                
                // âš ï¸ If current character < previous character â†’ NOT SORTED!
                if (strs[j][i] < strs[j - 1][i]) {
                    count++;    // This column must be deleted
                    break;      // No need to check further in this column
                }
            }
        }
        
        return count;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Key Insights
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ Core Idea: Check columns, not rows
   - Natural instinct: read strings row by row
   - Solution: think in terms of columns (vertical reading)

ğŸ”‘ Optimization: Early Break
   - Once we find one violation in a column, no need to check rest
   - Saves unnecessary comparisons

âš ï¸ Edge Cases:
   - Single string (n=1) â†’ all columns sorted â†’ return 0
   - All columns sorted â†’ return 0
   - All columns unsorted â†’ return m
   - Empty strings â†’ return 0 (though constraints prevent this)

ğŸ¯ Why This Works:
   - Each column is independent
   - A column is either sorted or not (binary decision)
   - Count all unsorted columns

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š Visual Grid Representation
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Example: ["zyx", "wvu", "tsr"]

Grid View:
    Col 0  Col 1  Col 2
    â†“      â†“      â†“
    z      y      x     â† strs[0]
    w      v      u     â† strs[1]
    t      s      r     â† strs[2]

Checking:
- Col 0: z â†’ w â†’ t (z > w, not sorted!) âŒ
- Col 1: y â†’ v â†’ s (y > v, not sorted!) âŒ
- Col 2: x â†’ u â†’ r (x > u, not sorted!) âŒ

Answer: 3 (all columns must be deleted)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¯ Step-by-Step Trace
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Input: ["abc", "bce", "cae"]

i=0 (Column 0: a,b,c):
  j=1: 'b' >= 'a' âœ…
  j=2: 'c' >= 'b' âœ…
  Sorted! count = 0

i=1 (Column 1: b,c,a):
  j=1: 'c' >= 'b' âœ…
  j=2: 'a' < 'c' âŒ BREAK!
  Not sorted! count = 1

i=2 (Column 2: c,e,e):
  j=1: 'e' >= 'c' âœ…
  j=2: 'e' >= 'e' âœ…
  Sorted! count = 1

Output: 1

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸš€ Variations & Extensions
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Variation 1: Return which columns to delete
  vector<int> columnsToDelete;
  for (int i = 0; i < m; i++) {
      bool sorted = true;
      for (int j = 1; j < n; j++) {
          if (strs[j][i] < strs[j-1][i]) {
              sorted = false;
              break;
          }
      }
      if (!sorted) columnsToDelete.push_back(i);
  }

Variation 2: Allow equal characters (non-decreasing)
  // Already handled! We use '<' not '<='

Variation 3: Sort in descending order instead
  if (strs[j][i] > strs[j-1][i]) {  // Change '<' to '>'
      count++;
      break;
  }

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Common Mistakes to Avoid
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âŒ Mistake 1: Checking rows instead of columns
  for (int i = 0; i < n; i++) {
      for (int j = 1; j < m; j++) {
          if (strs[i][j] < strs[i][j-1]) ...  // WRONG!
      }
  }

âŒ Mistake 2: Using '<=' instead of '<'
  if (strs[j][i] <= strs[j-1][i]) ...  // WRONG! Equal is OK!

âŒ Mistake 3: Not breaking after finding violation
  // Wastes time checking rest of column

âœ… Correct Approach: Check columns vertically with early break!

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Related Problems
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Similar patterns:
- Delete Columns to Make Sorted II (harder version)
- Delete Columns to Make Sorted III (hardest version)
- Valid Matrix Given Row and Column Sums
- Transpose Matrix
- Rotate Image

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
