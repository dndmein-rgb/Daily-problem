/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—“ï¸ Daily Question: December 16, 2024
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ Problem: 2110. Number of Smooth Descent Periods of a Stock
ğŸ“Œ Link: https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/
ğŸ·ï¸ Difficulty: Medium
ğŸ† Topics: Array, Math, Dynamic Programming

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

A smooth descent period is a subarray where each price is exactly 1 less than 
the previous price (strictly decreasing by 1).

Examples of smooth descent periods:
- [5, 4, 3, 2] âœ… (each differs by exactly -1)
- [5, 4] âœ…
- [5] âœ… (single element always counts)
- [5, 3] âŒ (difference is -2, not -1)
- [5, 5] âŒ (no change)

Count ALL possible smooth descent subarrays in the given prices array.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Approach
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Strategy: Sliding Window + Combinatorics

Key Insight:
If we have a consecutive smooth descent of length L, the number of subarrays
is: L Ã— (L + 1) / 2

This is because:
- 1 element: L subarrays
- 2 elements: (L-1) subarrays  
- 3 elements: (L-2) subarrays
- ...
- L elements: 1 subarray
Total = L + (L-1) + (L-2) + ... + 1 = L(L+1)/2

Algorithm:
1ï¸âƒ£ Track length of current smooth descent period
2ï¸âƒ£ When smooth descent breaks:
   â€¢ Add L(L+1)/2 to answer for that segment
   â€¢ Reset length to 1
3ï¸âƒ£ Continue until end of array
4ï¸âƒ£ Don't forget to add the last segment!

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” Example Walkthrough
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Input:  prices = [3, 2, 1, 4]

Step-by-step:
  Index:  0  1  2  3
  Price:  3  2  1  4
          â†“  â†“  â†“  â†“
  
  i=1: 2 = 3-1 âœ… â†’ len = 2
  i=2: 1 = 2-1 âœ… â†’ len = 3
  i=3: 4 â‰  1-1 âŒ â†’ Break! Calculate and reset
  
  Segment [3,2,1] has length 3:
  Subarrays count = 3Ã—4/2 = 6
  
  Subarrays:
  - [3]     âœ…
  - [2]     âœ…
  - [1]     âœ…
  - [3,2]   âœ…
  - [2,1]   âœ…
  - [3,2,1] âœ…
  
  Last segment [4] has length 1:
  Count = 1Ã—2/2 = 1
  
  Subarray:
  - [4]     âœ…

Total: 6 + 1 = 7

Output: 7

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â° Time Complexity:  O(n)
   â””â”€ Single pass through the array
   â””â”€ Each element processed exactly once
   
ğŸ’¾ Space Complexity: O(1)
   â””â”€ Only using two variables (ans, len)
   â””â”€ No additional data structures

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

class Solution {
public:
    long long getDescentPeriods(vector<int>& prices) {
        int n = prices.size();
        long long ans = 0;   // Total count of smooth descent periods
        long long len = 1;   // Current consecutive descent length
        
        // ğŸ” Iterate through prices starting from index 1
        for (int i = 1; i < n; i++) {
            // âœ… Check if current price continues the smooth descent
            // (current price = previous price - 1)
            if (prices[i] == prices[i - 1] - 1) {
                len++;  // Extend current descent period
            }
            else {
                // âŒ Descent breaks! Calculate subarrays for current segment
                // Formula: For length L, number of subarrays = L(L+1)/2
                ans += len * (len + 1) / 2;
                len = 1;  // Reset for new segment
            }
        }
        
        // ğŸ¯ Don't forget the last segment!
        // After loop ends, we still have one segment to count
        ans += len * (len + 1) / 2;
        
        return ans;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Key Insights
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ Core Formula: Number of subarrays in array of length L = L(L+1)/2
   This is the sum of first L natural numbers (triangular number)

ğŸ”‘ Pattern Recognition: This is a "grouping consecutive elements" problem
   Similar patterns appear in:
   - Longest consecutive sequence
   - Count increasing/decreasing subsequences
   - Stock span problems

âš ï¸ Edge Case: Don't forget to add the last segment after the loop!
   This is a common mistake in these types of problems

ğŸ¯ Why Combinatorics Works:
   For array [a, b, c] (length 3):
   - 1-element subarrays: [a], [b], [c] â†’ 3 subarrays
   - 2-element subarrays: [a,b], [b,c] â†’ 2 subarrays
   - 3-element subarrays: [a,b,c] â†’ 1 subarray
   Total = 3 + 2 + 1 = 6 = 3Ã—4/2 âœ…

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š Detailed Example
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Input: [5, 4, 3, 2, 1]

This is ONE continuous smooth descent of length 5.

All subarrays:
Length 1: [5], [4], [3], [2], [1]           â†’ 5 subarrays
Length 2: [5,4], [4,3], [3,2], [2,1]        â†’ 4 subarrays
Length 3: [5,4,3], [4,3,2], [3,2,1]         â†’ 3 subarrays
Length 4: [5,4,3,2], [4,3,2,1]              â†’ 2 subarrays
Length 5: [5,4,3,2,1]                       â†’ 1 subarray

Total = 5 + 4 + 3 + 2 + 1 = 15
Using formula: 5 Ã— 6 / 2 = 15 âœ…

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸš€ Alternative Approaches
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Approach 1 (Current): Count segments and use formula
âœ… Time: O(n), Space: O(1)

Approach 2: DP - Count ending at each position
- dp[i] = number of periods ending at position i
- If smooth descent continues: dp[i] = dp[i-1] + 1
- Otherwise: dp[i] = 1
- Sum all dp values
âœ… Time: O(n), Space: O(n) or O(1) if optimized

Approach 3: Brute Force - Check all subarrays
âŒ Time: O(nÂ³), Space: O(1) - Too slow!

Current approach is optimal! ğŸ¯

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Related Problems
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Similar pattern problems:
- Count Subarrays With Fixed Bounds
- Number of Arithmetic Slices
- Longest Consecutive Sequence
- Maximum Subarray (uses similar segment thinking)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
