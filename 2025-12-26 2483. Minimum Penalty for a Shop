
/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—“ï¸ Daily Question: December 26, 2025
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ Problem: 2483. Minimum Penalty for a Shop
ğŸ“Œ Link: https://leetcode.com/problems/minimum-penalty-for-a-shop/
ğŸ·ï¸ Difficulty: Medium
ğŸ† Topics: String, Prefix Sum, Greedy

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Given a customer visit log string with 'Y' (customer) and 'N' (no customer):
- Choose an hour to close the shop (0 â‰¤ j â‰¤ n)
- Penalty calculation:
  â€¢ +1 penalty for each hour shop is OPEN with NO customer ('N')
  â€¢ +1 penalty for each hour shop is CLOSED with a customer ('Y')
- Return the EARLIEST hour that minimizes the penalty

Key Notes:
- If shop closes at hour j, hours 0 to j-1 are open, hours j to n-1 are closed
- Closing at hour 0 means shop never opens
- Closing at hour n means shop is open for all n hours

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Approach 1: Map-Based Solution (Brute Force)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Strategy: Calculate penalty for each possible closing hour

Algorithm:
1ï¸âƒ£ Count all 'N's (penalty if open all hours)
2ï¸âƒ£ For each possible closing hour (0 to n):
   â€¢ Track 'Y's before closing (missed customers)
   â€¢ Track 'N's after closing (avoided penalties)
3ï¸âƒ£ Store all penalties in a map
4ï¸âƒ£ Find minimum penalty and return earliest hour with that penalty

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SOLUTION 1: MAP-BASED APPROACH (Less Optimal)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Solution_MapBased {
public:
    int bestClosingTime(string c) {
        int n = c.length();
        map<int, int> mp;  // {closing_hour: penalty}
        int nCount = 0, yCount = 0;
        
        // ğŸ“Š Count total 'N's (penalty if shop stays open all hours)
        for(int i = 0; i < n; i++) {
            if(c[i] == 'N') nCount++;
        }
        
        // Hour 0: Close immediately (miss all 'N's avoided, miss all 'Y's)
        mp[0] = nCount;
        
        // ğŸ”„ Calculate penalty for each closing hour
        for(int i = 1; i <= n; i++) {
            if(c[i-1] == 'Y') {
                yCount++;  // One more customer missed
                mp[i] = yCount + nCount;
            }
            else {  // c[i-1] == 'N'
                mp[i] = mp[i-1] - 1;  // One less 'N' to worry about
                nCount--;
            }
        }
        
        // ğŸ¯ Find minimum penalty (stored as maxF due to inverted logic)
        int maxF = 0;
        for(auto [hour, penalty] : mp) {
            maxF = max(maxF, penalty);
        }
        
        // ğŸ“ Return earliest hour with minimum penalty
        for(auto [hour, penalty] : mp) {
            if(penalty == maxF) return hour;
        }
        
        return 0;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Approach 2: Optimized Single Pass (Recommended â­)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Strategy: Track penalty changes incrementally without storing all values

Key Insight:
â€¢ Start by assuming we close at hour 0 â†’ penalty = all 'Y's (missed customers)
â€¢ As we consider closing later:
  - If we see 'Y' â†’ penalty DECREASES (served this customer)
  - If we see 'N' â†’ penalty INCREASES (shop open with no customer)
â€¢ Track minimum penalty and the earliest hour achieving it

Algorithm:
1ï¸âƒ£ Calculate initial penalty: count all 'Y's (closing at hour 0)
2ï¸âƒ£ For each hour i:
   â€¢ Update penalty based on customers[i]
   â€¢ If new penalty < min, update both min and best hour
3ï¸âƒ£ Return the earliest hour with minimum penalty

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SOLUTION 2: OPTIMIZED GREEDY APPROACH (Best Solution â­)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Solution {
public:
    int bestClosingTime(string customers) {
        int n = customers.length();
        
        // ğŸ¯ Initial penalty: miss all customers (close at hour 0)
        int penalty = 0;
        for(char c : customers) {
            if(c == 'Y') penalty++;
        }
        
        int bestHour = 0;      // Best closing hour found so far
        int minPenalty = penalty;  // Minimum penalty found so far
        
        // ğŸ”„ Try closing at each subsequent hour
        for(int i = 0; i < n; i++) {
            if(customers[i] == 'Y') {
                penalty--;  // âœ… Served this customer, reduce penalty
            }
            else {  // customers[i] == 'N'
                penalty++;  // âŒ Shop open with no customer, increase penalty
            }
            
            // ğŸ“‰ Found a better closing time?
            if(penalty < minPenalty) {
                minPenalty = penalty;
                bestHour = i + 1;  // Close AFTER this hour
            }
        }
        
        return bestHour;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” Example Walkthrough
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Example 1: customers = "YYNY"

Step 1: Initial state (close at hour 0)
        Y  Y  N  Y
        â†“  â†“     â†“
        All customers missed â†’ penalty = 3

Step 2: Try closing at hour 1 (after index 0)
        âœ… Y | Y N Y
        Served 1 customer: penalty = 3 - 1 = 2
        Update: bestHour = 1, minPenalty = 2

Step 3: Try closing at hour 2 (after index 1)
        âœ… Y âœ… Y | N Y
        Served another customer: penalty = 2 - 1 = 1
        Update: bestHour = 2, minPenalty = 1

Step 4: Try closing at hour 3 (after index 2)
        âœ… Y âœ… Y âŒ N | Y
        Open with no customer: penalty = 1 + 1 = 2
        No update (2 > 1)

Step 5: Try closing at hour 4 (after index 3)
        âœ… Y âœ… Y âŒ N âœ… Y |
        Served another customer: penalty = 2 - 1 = 1
        No update (1 = 1, not better)

Output: 2 (earliest hour with penalty = 1)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Example 2: customers = "NNNNN"

Initial: penalty = 0 (no customers to miss)
Hour 0 is optimal â†’ close immediately
Output: 0

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Example 3: customers = "YYYY"

Initial: penalty = 4 (miss all customers if close at 0)
Each hour reduces penalty: 4 â†’ 3 â†’ 2 â†’ 1 â†’ 0
Best is to stay open all hours
Output: 4

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

SOLUTION 1 (Map-Based):
â° Time Complexity:  O(n log n)
   â””â”€ O(n) for counting 'N's
   â””â”€ O(n log n) for map insertions
   â””â”€ O(n) for finding minimum
   
ğŸ’¾ Space Complexity: O(n)
   â””â”€ Map stores n+1 entries

SOLUTION 2 (Optimized):
â° Time Complexity:  O(n)
   â””â”€ Two passes: one to count 'Y's, one to find best hour
   â””â”€ Each character processed constant time
   
ğŸ’¾ Space Complexity: O(1)
   â””â”€ Only using fixed variables
   â””â”€ No additional data structures

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Key Insights
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ Core Idea: Penalty is a trade-off
   â€¢ Closing earlier â†’ miss customers ('Y')
   â€¢ Closing later â†’ pay for empty hours ('N')

ğŸ”‘ Critical Observation:
   â€¢ Penalty changes predictably at each hour
   â€¢ Don't need to recalculate from scratch
   â€¢ Track delta changes: -1 for 'Y', +1 for 'N'

âš ï¸ Edge Cases Handled:
   â€¢ All 'N's â†’ close at hour 0 immediately
   â€¢ All 'Y's â†’ stay open all hours
   â€¢ Mixed pattern â†’ find optimal balance

ğŸ¯ Why Greedy Works:
   â€¢ Each hour's contribution to penalty is independent
   â€¢ Can evaluate closing times left-to-right
   â€¢ First minimum found is the earliest (optimal)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š State Transitions (Solution 2)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Penalty Evolution:

Close at 0: penalty = count('Y')
           â†“
For each hour i:
    If 'Y' â†’ penalty--  (served customer)
    If 'N' â†’ penalty++  (wasted open hour)
           â†“
Track minimum and update bestHour when improved

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸš€ Example Trace (Solution 2)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Input: "YYNY"

Hour:         0    1    2    3    4
Customer:     -    Y    Y    N    Y
Penalty:      3    2    1    2    1
MinPenalty:   3    2    1    1    1
BestHour:     0    1    2    2    2
Action:       -    Y(-) Y(-) N(+) Y(-)

Final Answer: 2

Explanation:
â€¢ Start: penalty = 3 (miss all Y's if close at 0)
â€¢ Hour 1: Served 'Y' â†’ penalty = 2 âœ… Update best
â€¢ Hour 2: Served 'Y' â†’ penalty = 1 âœ… Update best  
â€¢ Hour 3: Open for 'N' â†’ penalty = 2 (no update)
â€¢ Hour 4: Served 'Y' â†’ penalty = 1 (equal, no update)

Return hour 2 (earliest with min penalty)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… Why Solution 2 is Better
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. âš¡ Linear Time: O(n) vs O(n log n)
2. ğŸ’¾ Constant Space: O(1) vs O(n)
3. ğŸ¯ Simpler Logic: Direct tracking vs map operations
4. ğŸš€ Better Performance: Single pass after initial count

Recommendation: Always use Solution 2 in interviews and production code!

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
