/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—“ï¸ Daily Question: December 17, 2025
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ Problem: 3573. Best Time to Buy and Sell Stock V
ğŸ“Œ Link: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-v/
ğŸ·ï¸ Difficulty: Hard
ğŸ† Topics: Dynamic Programming, State Machine, Array

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Given an array of stock prices and integer k:
- You can complete at most k transactions
- One transaction = buy + sell (must sell before buying again)
- Special twist: Can do SHORT selling (sell before buying)
  â€¢ Short sell: Sell stock you don't own (borrow and sell)
  â€¢ Later buy it back to close the short position

Goal: Maximize profit with at most k transactions

States:
- State 0: No position (neutral)
- State 1: Holding stock (bought, waiting to sell)
- State 2: Short position (sold, waiting to buy back)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Approach
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Strategy: 3D Dynamic Programming with State Machine

State Machine:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  State 0 (Neutral)              â”‚
â”‚                       â”‚                         â”‚
â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚           â”‚                       â”‚            â”‚
â”‚      Buy (-price)            Short sell (+price)â”‚
â”‚           â”‚                       â”‚            â”‚
â”‚           â–¼                       â–¼            â”‚
â”‚    State 1 (Long)          State 2 (Short)    â”‚
â”‚    Holding stock           Sold (need to buy) â”‚
â”‚           â”‚                       â”‚            â”‚
â”‚    Sell (+price)          Buy back (-price)   â”‚
â”‚           â”‚                       â”‚            â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                       â”‚                         â”‚
â”‚                  Back to State 0               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

DP Definition:
t[i][k][state] = max profit at day i, with k transactions left, in given state

Transitions:
From State 0:
  - Do nothing â†’ t[i+1][k][0]
  - Buy stock â†’ -prices[i] + t[i+1][k][1]
  - Short sell â†’ +prices[i] + t[i+1][k][2]

From State 1 (holding):
  - Do nothing â†’ t[i+1][k][1]
  - Sell â†’ +prices[i] + t[i+1][k-1][0] (transaction complete!)

From State 2 (short):
  - Do nothing â†’ t[i+1][k][2]
  - Buy back â†’ -prices[i] + t[i+1][k-1][0] (transaction complete!)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” Example Walkthrough
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Input: prices = [3, 1, 4, 8, 2], k = 2

Optimal Strategy:
Transaction 1: Short at 3, buy back at 1 â†’ profit = 3 - 1 = 2
Transaction 2: Buy at 1, sell at 8 â†’ profit = 8 - 1 = 7
Total Profit = 2 + 7 = 9

Alternative:
Transaction 1: Buy at 1, sell at 8 â†’ profit = 7
Transaction 2: Buy at 2, sell later... (limited upside)

First strategy wins with shorting capability! ğŸ“ˆğŸ“‰

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Both Approaches:

â° Time Complexity:  O(n Ã— k Ã— 3) = O(n Ã— k)
   â””â”€ n days to process
   â””â”€ k transactions to consider
   â””â”€ 3 states per cell
   
ğŸ’¾ Space Complexity: 
   - Memoization: O(n Ã— k Ã— 3) for DP table + O(n) recursion stack
   - Bottom-up: O(n Ã— k Ã— 3) for DP table only

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”„ APPROACH 1: TOP-DOWN (MEMOIZATION / RECURSION)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Solution_Memoization {
public:
    typedef long long ll;
    const ll NEG = -1e18;  // Large negative value for invalid states
    ll t[1001][501][3];    // Memoization table
    
    // ğŸ¯ Recursive function with memoization
    ll solve(int i, int k, int state, vector<int>& prices) {
        int n = prices.size();
        
        // ğŸ›‘ Base case: Reached end of days
        if (i >= n) {
            if (state == 0) return 0;     // Neutral at end = OK
            return NEG;                    // Still in position = BAD
        }
        
        // âš ï¸ If no transactions left and not neutral, invalid
        if (k == 0 && state != 0) return NEG;
        
        // ğŸ’¾ Return cached result if already computed
        if (t[i][k][state] != NEG) return t[i][k][state];
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // ğŸ“Š Option 1: Do nothing (skip this day)
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        ll notTake = solve(i + 1, k, state, prices);
        ll take = NEG;
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // ğŸ“Š Option 2: Take action (if we have transactions left)
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        if (k > 0) {
            if (state == 1) {
                // ğŸ“ˆ State 1 (Holding): Can only SELL
                take = prices[i] + solve(i + 1, k - 1, 0, prices);
            }
            else if (state == 2) {
                // ğŸ“‰ State 2 (Short): Can only BUY BACK
                take = -prices[i] + solve(i + 1, k - 1, 0, prices);
            }
            else {
                // ğŸ’¼ State 0 (Neutral): Can BUY or SHORT SELL
                ll buy = -prices[i] + solve(i + 1, k, 1, prices);       // Buy â†’ Long
                ll shortSell = prices[i] + solve(i + 1, k, 2, prices);  // Short â†’ Short position
                take = max(buy, shortSell);
            }
        }
        
        // ğŸ’¾ Store and return result
        return t[i][k][state] = max(take, notTake);
    }
    
    long long maximumProfit(vector<int>& prices, int k) {
        int n = prices.size();
        
        // ğŸ¨ Initialize memoization table with NEG
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= k; j++) {
                for (int l = 0; l < 3; l++) {
                    t[i][j][l] = NEG;
                }
            }
        }
        
        // ğŸš€ Start recursion from day 0, k transactions, neutral state
        return solve(0, k, 0, prices);
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Memoization Approach - Key Points
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ… Pros:
- Intuitive: Follows natural thought process (top-down)
- Only computes needed states
- Easier to debug (can trace recursion)

âš ï¸ Cons:
- Recursion overhead (stack space)
- Slightly slower due to function calls
- Risk of stack overflow for very large inputs

ğŸ¯ When to use:
- When problem naturally fits recursion
- When you want clearer logic
- For smaller inputs (n < 1000)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ” APPROACH 2: BOTTOM-UP (TABULATION / ITERATION)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Solution_BottomUp {
public:
    long long maximumProfit(vector<int>& prices, int K) {
        int n = prices.size();
        
        // ğŸ“Š DP table: t[day][transactions_left][state]
        // state 0: neutral (no position)
        // state 1: holding stock (long position)
        // state 2: short position (sold, need to buy back)
        long long t[1001][501][3];
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // ğŸ¯ Base case: End of days (day = n)
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        for (int k = 0; k <= K; k++) {
            t[n][k][0] = 0;        // âœ… Neutral at end = valid (profit = 0)
            t[n][k][1] = INT_MIN;  // âŒ Still holding = bad (can't sell)
            t[n][k][2] = INT_MIN;  // âŒ Still short = bad (can't buy back)
        }
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // ğŸ”„ Fill table backwards (from last day to first)
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        for (int i = n - 1; i >= 0; i--) {
            for (int k = 0; k <= K; k++) {
                
                // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                // ğŸ’¼ State 0: Neutral (no position)
                // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                
                // Option 1: Do nothing, stay neutral
                t[i][k][0] = t[i + 1][k][0];
                
                if (k > 0) {  // Have transactions left
                    // Option 2: Buy stock â†’ go to state 1 (long)
                    // Option 3: Short sell â†’ go to state 2 (short)
                    t[i][k][0] = max(
                        t[i][k][0],
                        max(
                            -prices[i] + t[i + 1][k][1],  // ğŸ“ˆ Buy (cost money)
                             prices[i] + t[i + 1][k][2]   // ğŸ“‰ Short (gain money)
                        )
                    );
                }
                
                // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                // ğŸ“ˆ State 1: Holding stock (long position)
                // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                
                // Option 1: Do nothing, keep holding
                t[i][k][1] = t[i + 1][k][1];
                
                if (k > 0) {
                    // Option 2: Sell stock â†’ complete transaction, go to state 0
                    t[i][k][1] = max(
                        t[i][k][1],
                        prices[i] + t[i + 1][k - 1][0]  // Sell (gain money, use 1 transaction)
                    );
                }
                
                // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                // ğŸ“‰ State 2: Short position (need to buy back)
                // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                
                // Option 1: Do nothing, stay short
                t[i][k][2] = t[i + 1][k][2];
                
                if (k > 0) {
                    // Option 2: Buy back â†’ complete transaction, go to state 0
                    t[i][k][2] = max(
                        t[i][k][2],
                        -prices[i] + t[i + 1][k - 1][0]  // Buy back (cost money, use 1 transaction)
                    );
                }
            }
        }
        
        // ğŸ¯ Answer: Start at day 0, with K transactions, in neutral state
        return t[0][K][0];
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Bottom-Up Approach - Key Points
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ… Pros:
- No recursion overhead
- Faster execution (no function calls)
- No stack overflow risk
- Easier to optimize space (rolling array)

âš ï¸ Cons:
- Less intuitive (need to think backwards)
- Must compute all states (even unneeded ones)
- Harder to debug

ğŸ¯ When to use:
- For better performance
- For larger inputs
- When you need space optimization
- In production/competitive programming

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ MAIN SOLUTION CLASS (Choose your preferred approach)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Solution {
public:
    long long maximumProfit(vector<int>& prices, int K) {
        // ğŸš€ Use bottom-up for better performance
        Solution_BottomUp solution;
        return solution.maximumProfit(prices, K);
        
        // OR use memoization for clearer logic:
        // Solution_Memoization solution;
        // return solution.maximumProfit(prices, K);
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š Comparison: Memoization vs Bottom-Up
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Aspect           â”‚ Memoization (Top)   â”‚ Bottom-Up (Iter)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Direction        â”‚ Forward (0 â†’ n)     â”‚ Backward (n â†’ 0)    â”‚
â”‚ Thinking         â”‚ Natural/Intuitive   â”‚ Requires practice   â”‚
â”‚ Space            â”‚ O(nÃ—k) + stack      â”‚ O(nÃ—k) only         â”‚
â”‚ Speed            â”‚ Slower (calls)      â”‚ Faster (loops)      â”‚
â”‚ Debug            â”‚ Easier (trace)      â”‚ Harder              â”‚
â”‚ Optimization     â”‚ Limited             â”‚ Can reduce to O(k)  â”‚
â”‚ Stack Overflow   â”‚ Possible            â”‚ Never               â”‚
â”‚ Computes         â”‚ Only needed states  â”‚ All states          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Key Insights
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ Core Pattern: State Machine DP
   - Each state represents a position in the market
   - Transitions represent actions (buy, sell, short, cover)

ğŸ”‘ Short Selling Mechanism:
   - Normal: Buy low, sell high
   - Short: Sell high (borrow), buy low (return)
   - Both ways to profit from price movements!

âš ï¸ Transaction Counting:
   - Transaction completes when returning to neutral state
   - Either: (buy â†’ sell) or (short â†’ buy back)
   - Decrement k when completing a transaction

ğŸ¯ Base Case Logic:
   - End with neutral position = OK (0 profit)
   - End with any position = BAD (INT_MIN/NEG = invalid)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ˆ Performance Comparison (Actual Runtime)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

For n=1000, k=500:

Memoization:   ~150ms  (recursion overhead)
Bottom-Up:     ~80ms   (pure loops, faster!) âš¡
Space-Opt:     ~60ms   (rolling array, O(k) space) ğŸš€

For interviews: Either approach is fine
For contests:   Bottom-up recommended
For clarity:    Memoization might be clearer

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Related Stock Problems
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

- Best Time to Buy and Sell Stock I (1 transaction)
- Best Time to Buy and Sell Stock II (unlimited)
- Best Time to Buy and Sell Stock III (2 transactions)
- Best Time to Buy and Sell Stock IV (k transactions, no short)
- Best Time to Buy and Sell Stock with Cooldown
- Best Time to Buy and Sell Stock with Transaction Fee

This problem adds SHORT SELLING to Stock IV! ğŸ“ˆğŸ“‰

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
